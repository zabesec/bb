import json
import os
import signal
import sys
import time
from datetime import datetime, timedelta
from typing import Dict, List, Set

import requests

DISCORD_WEBHOOK_URL = os.getenv("DISCORD_WEBHOOK_URL", "YOUR_DISCORD_WEBHOOK_URL_HERE")
CHECK_INTERVAL_HOURS = int(os.getenv("CHECK_INTERVAL_HOURS", "4"))
CVE_API_BASE = "https://services.nvd.nist.gov/rest/json/cves/2.0"
STATE_FILE = "/data/cve_tracker_state.json"

TARGETS = [
    {"hash": "2141724739", "name": "Juniper Networks"},
    {"query": 'http.component:"Atlassian Confluence" http.status:200', "name": "Confluence"},
    {"query": 'http.component:"PHP" port:80,443,8080', "name": "PHP CGI Windows"},
    {"query": 'http.title:"Dashboard [Jenkins]"', "name": "Jenkins"},
    {"query": "X-Jenkins port:8080", "name": "Jenkins Alt"},
    {"query": 'http.title:"HugeGraph" port:8080', "name": "HugeGraph Server"},
    {"query": 'product:"OpenSSH" port:22', "name": "OpenSSH RegreSSHion"},
    {"query": 'http.title:"HFS" "Rejetto"', "name": "Rejetto HFS"},
    {"query": 'http.html:"Rejetto" port:80,8080', "name": "Rejetto HFS Alt"},
    {"query": 'http.title:"Fortinet"', "name": "FortiOS Management"},
    {"query": 'http.html:"fortinet" port:443,4433', "name": "Fortinet Devices"},
    {"query": 'http.title:"Ivanti Connect Secure"', "name": "Ivanti Connect Secure"},
    {"query": 'http.html:"Pulse Secure"', "name": "Pulse Secure"},
    {"query": 'http.html:"NetAlertX" port:80,8080', "name": "NetAlertX"},
    {"query": 'http.component:"Next.js" http.status:200', "name": "Next.js Apps"},
    {"query": 'http.html:"__next" port:3000,80,443', "name": "Next.js Apps Alt"},
    {"query": 'http.title:"FortiNAC"', "name": "FortiNAC"},
    {"query": 'http.title:"CrushFTP" -cloudflare', "name": "CrushFTP"},
    {"query": 'http.html:"wp-content/plugins/elementor-pro"', "name": "WordPress Elementor Pro"},
    {"query": 'http.title:"ColdFusion Administrator"', "name": "ColdFusion Admin"},
    {"query": 'http.title:"Apache Tomcat" port:8080,8443', "name": "Tomcat Manager"},
    {"query": 'http.title:"Grafana" -login port:3000', "name": "Grafana"},
    {"query": 'http.title:"SonarQube" -auth', "name": "SonarQube"},
    {"query": 'http.title:"RabbitMQ Management"', "name": "RabbitMQ"},
    {"query": 'http.title:"Kubernetes Dashboard"', "name": "Kubernetes Dashboard"},
    {"query": 'http.html:"webvpn" cisco', "name": "Cisco ASA WebVPN"},
]

KEYWORD_MAP = {
    "Juniper Networks": ["juniper", "junos"],
    "Confluence": ["confluence", "atlassian"],
    "PHP CGI Windows": ["php", "cgi"],
    "Jenkins": ["jenkins"],
    "HugeGraph Server": ["hugegraph"],
    "OpenSSH RegreSSHion": ["openssh", "ssh"],
    "Rejetto HFS": ["rejetto", "hfs"],
    "FortiOS Management": ["fortios", "fortigate"],
    "Fortinet Devices": ["fortinet"],
    "Ivanti Connect Secure": ["ivanti"],
    "Pulse Secure": ["pulse secure"],
    "NetAlertX": ["netalertx"],
    "Next.js Apps": ["next.js", "nextjs"],
    "FortiNAC": ["fortinac"],
    "CrushFTP": ["crushftp"],
    "WordPress Elementor Pro": ["wordpress", "elementor"],
    "ColdFusion Admin": ["coldfusion"],
    "Tomcat Manager": ["tomcat", "apache tomcat"],
    "Grafana": ["grafana"],
    "SonarQube": ["sonarqube"],
    "RabbitMQ": ["rabbitmq"],
    "Kubernetes Dashboard": ["kubernetes"],
    "Cisco ASA WebVPN": ["cisco asa", "webvpn"],
}


class CVETracker:
    def __init__(self):
        self.seen_cves: Set[str] = set()
        self.running = True
        self.load_state()
        signal.signal(signal.SIGTERM, self.handle_signal)
        signal.signal(signal.SIGINT, self.handle_signal)

    def handle_signal(self, signum, frame):
        print(f"\nReceived signal {signum}, shutting down gracefully...")
        self.running = False
        self.save_state()
        sys.exit(0)

    def load_state(self):
        os.makedirs(os.path.dirname(STATE_FILE), exist_ok=True)
        if os.path.exists(STATE_FILE):
            try:
                with open(STATE_FILE, 'r') as f:
                    data = json.load(f)
                    self.seen_cves = set(data.get('seen_cves', []))
                print(f"[{datetime.now()}] Loaded {len(self.seen_cves)} previously seen CVEs")
            except Exception as e:
                print(f"[{datetime.now()}] Error loading state: {e}")

    def save_state(self):
        try:
            with open(STATE_FILE, 'w') as f:
                json.dump({'seen_cves': list(self.seen_cves)}, f)
        except Exception as e:
            print(f"[{datetime.now()}] Error saving state: {e}")

    def fetch_recent_cves(self, keywords: List[str], days_back: int = 1) -> List[Dict]:
        cves = []
        pub_start = (datetime.now() - timedelta(days=days_back)).strftime('%Y-%m-%dT00:00:00.000')
        pub_end = datetime.now().strftime('%Y-%m-%dT23:59:59.999')

        for keyword in keywords:
            try:
                params = {
                    'keywordSearch': keyword,
                    'pubStartDate': pub_start,
                    'pubEndDate': pub_end,
                }

                response = requests.get(CVE_API_BASE, params=params, timeout=30)

                if response.status_code == 200:
                    data = response.json()
                    vulnerabilities = data.get('vulnerabilities', [])
                    cves.extend(vulnerabilities)
                elif response.status_code == 403:
                    print(f"[{datetime.now()}] Rate limited, waiting...")
                    time.sleep(6)

                time.sleep(0.6)

            except Exception as e:
                print(f"[{datetime.now()}] Error fetching CVEs for {keyword}: {e}")

        return cves

    def parse_cve(self, vuln_data: Dict) -> Dict:
        cve = vuln_data.get('cve', {})
        cve_id = cve.get('id', 'Unknown')

        descriptions = cve.get('descriptions', [])
        description = next((d['value'] for d in descriptions if d['lang'] == 'en'), 'No description')

        metrics = cve.get('metrics', {})
        cvss_score = 'N/A'
        severity = 'N/A'

        if 'cvssMetricV31' in metrics and metrics['cvssMetricV31']:
            cvss_data = metrics['cvssMetricV31'][0]['cvssData']
            cvss_score = cvss_data.get('baseScore', 'N/A')
            severity = cvss_data.get('baseSeverity', 'N/A')
        elif 'cvssMetricV2' in metrics and metrics['cvssMetricV2']:
            cvss_data = metrics['cvssMetricV2'][0]['cvssData']
            cvss_score = cvss_data.get('baseScore', 'N/A')
            severity = cvss_data.get('baseSeverity', 'N/A')

        published = cve.get('published', 'Unknown')

        references = cve.get('references', [])
        ref_urls = [ref.get('url', '') for ref in references[:3]]

        return {
            'id': cve_id,
            'description': description[:500],
            'cvss_score': cvss_score,
            'severity': severity,
            'published': published,
            'references': ref_urls,
        }

    def send_discord_notification(self, cve: Dict, target_name: str):
        color_map = {
            'CRITICAL': 0xFF0000,
            'HIGH': 0xFF6600,
            'MEDIUM': 0xFFCC00,
            'LOW': 0x00FF00,
            'N/A': 0x808080,
        }

        color = color_map.get(cve['severity'], 0x808080)

        embed = {
            "title": f"ðŸš¨ New CVE Alert: {cve['id']}",
            "description": f"**Target:** {target_name}\n\n{cve['description']}",
            "color": color,
            "fields": [
                {"name": "CVSS Score", "value": str(cve['cvss_score']), "inline": True},
                {"name": "Severity", "value": cve['severity'], "inline": True},
                {"name": "Published", "value": cve['published'][:10], "inline": True},
            ],
            "footer": {"text": f"CVE Tracker â€¢ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"},
            "url": f"https://nvd.nist.gov/vuln/detail/{cve['id']}"
        }

        if cve['references']:
            refs = '\n'.join([f"â€¢ {url}" for url in cve['references']])
            embed['fields'].append({"name": "References", "value": refs[:1024], "inline": False})

        payload = {"embeds": [embed]}

        try:
            response = requests.post(DISCORD_WEBHOOK_URL, json=payload, timeout=10)
            if response.status_code == 204:
                print(f"[{datetime.now()}] Sent Discord notification for {cve['id']}")
            else:
                print(f"[{datetime.now()}] Discord webhook error: {response.status_code}")
        except Exception as e:
            print(f"[{datetime.now()}] Error sending Discord notification: {e}")

    def check_for_new_cves(self):
        print(f"\n[{datetime.now()}] CVE Check Started")

        new_cves_found = 0

        for target in TARGETS:
            if not self.running:
                break

            target_name = target['name']
            keywords = KEYWORD_MAP.get(target_name, [target_name.lower()])

            vulnerabilities = self.fetch_recent_cves(keywords, days_back=1)

            for vuln in vulnerabilities:
                if not self.running:
                    break

                cve_data = self.parse_cve(vuln)
                cve_id = cve_data['id']

                if cve_id not in self.seen_cves:
                    print(f"[{datetime.now()}] New CVE: {cve_id} (Severity: {cve_data['severity']})")
                    self.seen_cves.add(cve_id)
                    self.send_discord_notification(cve_data, target_name)
                    new_cves_found += 1
                    time.sleep(1)

        self.save_state()

        print(f"[{datetime.now()}] Check Complete: {new_cves_found} new CVE(s) found")
        print(f"[{datetime.now()}] Next check in {CHECK_INTERVAL_HOURS} hours\n")

    def run(self):
        print(f"[{datetime.now()}] CVE Tracker Started")
        print(f"[{datetime.now()}] Monitoring {len(TARGETS)} targets")
        print(f"[{datetime.now()}] Check interval: Every {CHECK_INTERVAL_HOURS} hours")
        print(f"[{datetime.now()}] Discord webhook configured: {DISCORD_WEBHOOK_URL != 'YOUR_DISCORD_WEBHOOK_URL_HERE'}")

        self.check_for_new_cves()

        while self.running:
            try:
                next_check = datetime.now() + timedelta(hours=CHECK_INTERVAL_HOURS)
                print(f"[{datetime.now()}] Sleeping until {next_check.strftime('%Y-%m-%d %H:%M:%S')}")

                for _ in range(CHECK_INTERVAL_HOURS * 3600):
                    if not self.running:
                        break
                    time.sleep(1)

                if self.running:
                    self.check_for_new_cves()

            except Exception as e:
                print(f"[{datetime.now()}] Error in main loop: {e}")
                time.sleep(60)


def main():
    tracker = CVETracker()
    tracker.run()


if __name__ == "__main__":
    main()
